import os
import json
import re
import shutil
import subprocess
from datetime import datetime
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from git import Repo, exc

# ===================================
# === CONFIGURATION (C·∫•u h√¨nh) =====
# ===================================

# --- Bot & Telegram ---
BOT_TOKEN = os.getenv("BOT_TOKEN", "7664663330:AAGk132lgzUlSlKPtHYTds5GHtvuLEjvfRM")

# --- Git Repositories ---
# Repo ngu·ªìn ch·ª©a code c·∫ßn ki·ªÉm tra v√† deploy
SOURCE_REPO_URL = "http://10.168.3.145:8887/outsource.git"
SOURCE_REPO_BRANCH = "UPCODE_VTT"

# Repo ƒë√≠ch, n∆°i s·∫Ω ch·ª©a code ƒë√£ ƒë∆∞·ª£c l√†m s·∫°ch v√† deploy
DEPLOY_REPO_URL = "https://scm.devops.vnpt.vn/scm.ehealth.it/PM2_VNPTHISL2_DEPLOY.git"
DEPLOY_REPO_BRANCH = "master"

# --- Paths (ƒê∆∞·ªùng d·∫´n) ---
# S·ª≠ d·ª•ng m·ªôt th∆∞ m·ª•c g·ªëc ƒë·ªÉ ch·ª©a m·ªçi th·ª© cho g·ªçn
WORKSPACE = os.path.dirname(os.path.abspath(__file__))
REPO_PATH = os.path.join(WORKSPACE, "outsource")
DEST_PATH = os.path.join(WORKSPACE, "outsource_cleaned")
JSON_PATH = os.path.join(WORKSPACE, "ProvinceRules.json")
DEPLOY_REPO = os.path.join(WORKSPACE, "PM2_VNPTHISL2_DEPLOY")

# --- Validation Rules ---
MAX_TELEGRAM_MESSAGE_LEN = 4000
FORBIDDEN_SQL_KEYWORDS = ["update", "delete", "insert", "truncate", "drop"]

# ===================================
# === UTILITY FUNCTIONS (H√†m ti·ªán √≠ch) ===
# ===================================

def prepare_repo(repo_path, repo_url, branch):
    """
    Chu·∫©n b·ªã m·ªôt repository: clone n·∫øu ch∆∞a c√≥, pull n·∫øu ƒë√£ c√≥.
    """
    print(f"--- Chu·∫©n b·ªã kho git t·∫°i: {repo_path} ---")
    try:
        if os.path.exists(repo_path):
            print(f"Th∆∞ m·ª•c ƒë√£ t·ªìn t·∫°i. ƒêang c·∫≠p nh·∫≠t t·ª´ branch '{branch}'...")
            repo = Repo(repo_path)
            # Ki·ªÉm tra xem remote origin c√≥ ƒë√∫ng kh√¥ng
            if repo.remotes.origin.url != repo_url:
                 print(f"URL c·ªßa remote ƒë√£ thay ƒë·ªïi. ƒêang c·∫≠p nh·∫≠t...")
                 repo.delete_remote('origin')
                 repo.create_remote('origin', repo_url)
            repo.git.checkout(branch)
            repo.git.pull()
            print("‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng.")
        else:
            print(f"Th∆∞ m·ª•c ch∆∞a t·ªìn t·∫°i. ƒêang clone t·ª´ branch '{branch}'...")
            Repo.clone_from(repo_url, repo_path, branch=branch)
            print("‚úÖ Clone th√†nh c√¥ng.")
        return True
    except exc.GitCommandError as e:
        print(f"‚ùå L·ªñI GIT: Kh√¥ng th·ªÉ chu·∫©n b·ªã kho git {repo_path}.")
        print(f"L·ªói chi ti·∫øt: {e}")
        return False
    except Exception as e:
        print(f"‚ùå L·ªñI KH√îNG X√ÅC ƒê·ªäNH: {e}")
        return False

def remove_sql_comments(text):
    text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)
    text = re.sub(r'--.*', '', text)
    return text

def load_province_rules(json_path):
    if not os.path.exists(json_path):
        print(f"‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y file ProvinceRules.json t·∫°i '{json_path}'")
        return {}
    with open(json_path, 'r', encoding='utf-8') as f:
        province_data = json.load(f)
    rules = {}
    for entry in province_data:
        ma_tinh = entry["ma_tinh"].strip().lower()
        if ma_tinh:
            rules[ma_tinh] = [s.lower() for s in entry["duoi_file"]]
    return rules

def get_today_date_folder(repo_path):
    today_str = datetime.now().strftime("%Y%m%d")
    repo = Repo(repo_path)
    all_files = repo.git.ls_files().splitlines()
    folder_dates = {f.split("/")[0] for f in all_files if re.fullmatch(r"\d{8}", f.split("/")[0])}
    return today_str if today_str in folder_dates else None

def validate_file(repo_path, file, commit_msg, province_rules):
    matched = False
    ma_tinh_match = None
    reason = ""

    for ma_tinh, duoi_files in province_rules.items():
        if ma_tinh in commit_msg:
            ma_tinh_match = ma_tinh
            if any(duoi in file.lower() for duoi in duoi_files):
                matched = True
                break

    if not ma_tinh_match:
        return False, "M√£ t·ªânh kh√¥ng h·ª£p l·ªá", None
    elif not matched:
        return False, "T√™n file kh√¥ng ch·ª©a m√£ ƒë∆°n v·ªã h·ª£p l·ªá", ma_tinh_match

    if file.lower().endswith(".sql"):
        if "duc" not in file.lower():
            file_path = os.path.join(repo_path, file)
            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as sql_file:
                    lines = sql_file.readlines()
                    cleaned = remove_sql_comments("".join(lines).lower())
                    found = [kw for kw in FORBIDDEN_SQL_KEYWORDS if kw in cleaned]
                    if found:
                        return False, f"File SQL ch·ª©a t·ª´ kh√≥a kh√¥ng h·ª£p l·ªá: {', '.join(found)}", ma_tinh_match
                    while lines and not lines[-1].strip():
                        lines.pop()
                    if not lines or not lines[-1].strip().endswith("/"):
                        return False, "File SQL kh√¥ng k·∫øt th√∫c b·∫±ng d·∫•u '/'", ma_tinh_match
            except Exception as e:
                return False, f"Kh√¥ng th·ªÉ ƒë·ªçc file: {e}", ma_tinh_match
    return True, "", ma_tinh_match

def copy_folder(src, dst):
    if os.path.exists(dst):
        shutil.rmtree(dst)
    shutil.copytree(src, dst)

# ===================================
# === TELEGRAM COMMAND HANDLERS =====
# ===================================

async def checkinvalidfile_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    ma_tinh_filter = context.args[0].strip().lower() if context.args else None
    
    await context.bot.send_message(chat_id=chat_id, text="‚è≥ ƒêang c·∫≠p nh·∫≠t l·∫°i repo ngu·ªìn...")
    if not prepare_repo(REPO_PATH, SOURCE_REPO_URL, SOURCE_REPO_BRANCH):
        await context.bot.send_message(chat_id=chat_id, text="‚ùå L·ªói nghi√™m tr·ªçng khi c·∫≠p nh·∫≠t repo ngu·ªìn. Vui l√≤ng ki·ªÉm tra log.")
        return

    province_rules = load_province_rules(JSON_PATH)
    if not province_rules:
         await context.bot.send_message(chat_id=chat_id, text="‚ùå Kh√¥ng th·ªÉ t·∫£i file lu·∫≠t. Ki·ªÉm tra file `ProvinceRules.json`.")
         return

    if ma_tinh_filter and ma_tinh_filter not in province_rules:
        await update.message.reply_text(f"‚ùå M√£ t·ªânh `{ma_tinh_filter}` kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")
        return

    latest_folder = get_today_date_folder(REPO_PATH)
    if not latest_folder:
        await context.bot.send_message(chat_id=chat_id, text="‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c c·ªßa ng√†y h√¥m nay trong repo ngu·ªìn.")
        return

    target_folder = latest_folder + "/"
    await context.bot.send_message(chat_id=chat_id, text=f"üìÇ ƒêang ki·ªÉm tra th∆∞ m·ª•c: `{target_folder}`")
    
    repo = Repo(REPO_PATH)
    all_files = repo.git.ls_files().splitlines()
    filtered_files = [f for f in all_files if f.startswith(target_folder)]
    report = []
    for file in filtered_files:
        commits = list(repo.iter_commits(paths=file, max_count=1))
        if not commits: continue
        commit = commits[0]
        commit_msg = commit.message.strip().lower()
        if ma_tinh_filter and ma_tinh_filter not in commit_msg: continue
        is_valid, reason, ma_tinh_match = validate_file(REPO_PATH, file, commit_msg, province_rules)
        if not is_valid:
            report.append(
                f"‚ùå File kh√¥ng h·ª£p l·ªá: {file}\n"
                f"   üìå L√Ω do: {reason}\n"
                f"   üìù M√£ t·ªânh: {ma_tinh_match or 'Kh√¥ng x√°c ƒë·ªãnh'}\n"
                f"   üë§ Author: {commit.author.name}\n"
                f"   üìÖ Date:   {commit.committed_datetime}"
            )
    if not report:
        report = [f"‚úÖ T·∫•t c·∫£ file h·ª£p l·ªá cho t·ªânh `{ma_tinh_filter.upper()}`." if ma_tinh_filter else "‚úÖ T·∫•t c·∫£ file ƒë·ªÅu h·ª£p l·ªá."]

    # G·ª≠i report
    current_msg = ""
    for line in report:
        if len(current_msg) + len(line) + 2 > MAX_TELEGRAM_MESSAGE_LEN:
            await context.bot.send_message(chat_id=chat_id, text=current_msg.strip())
            current_msg = ""
        current_msg += line + "\n\n"
    if current_msg.strip():
        await context.bot.send_message(chat_id=chat_id, text=current_msg.strip())


async def upcode_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if len(context.args) < 2:
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå C√∫ ph√°p sai!\n/upcode <th·ªùi_gian> <commit_message>\n\nV√≠ d·ª•: `/upcode 17H19 https://cntt.vnpt.vn/browse/IT360-1545724`"
        )
        return

    time_str = context.args[0].strip().upper()
    commit_msg_today = " ".join(context.args[1:]).strip()

    if not re.match(r"^\d{2}H\d{2}$", time_str):
        await context.bot.send_message(chat_id=chat_id, text=f"‚ùå ƒê·ªãnh d·∫°ng th·ªùi gian '{time_str}' kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: 17H19")
        return

    await context.bot.send_message(chat_id=chat_id, text=f"üöÄ B·∫Øt ƒë·∫ßu deploy v·ªõi th·ªùi gian `{time_str}`...")
    
    # 1. Pull repo ngu·ªìn
    await context.bot.send_message(chat_id=chat_id, text="[1/6] ‚è≥ ƒêang c·∫≠p nh·∫≠t repo ngu·ªìn...")
    if not prepare_repo(REPO_PATH, SOURCE_REPO_URL, SOURCE_REPO_BRANCH):
        await context.bot.send_message(chat_id=chat_id, text="‚ùå L·ªói khi c·∫≠p nh·∫≠t repo ngu·ªìn.")
        return
    await context.bot.send_message(chat_id=chat_id, text="‚úÖ Repo ngu·ªìn ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")

    latest_folder = get_today_date_folder(REPO_PATH)
    if not latest_folder:
        await context.bot.send_message(chat_id=chat_id, text="‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c ng√†y h√¥m nay trong repo ngu·ªìn.")
        return

    # 2. Copy sang th∆∞ m·ª•c l√†m s·∫°ch
    await context.bot.send_message(chat_id=chat_id, text=f"[2/6] üìÇ ƒêang copy `{latest_folder}` ƒë·ªÉ x·ª≠ l√Ω...")
    original_path = os.path.join(REPO_PATH, latest_folder)
    cleaned_path = os.path.join(DEST_PATH, latest_folder)
    try:
        copy_folder(original_path, cleaned_path)
    except Exception as e:
        await context.bot.send_message(chat_id=chat_id, text=f"‚ùå L·ªói khi sao ch√©p th∆∞ m·ª•c: {e}")
        return

    # 3. D·ªçn d·∫πp file kh√¥ng h·ª£p l·ªá v√† jrxml
    await context.bot.send_message(chat_id=chat_id, text="[3/6] üßπ ƒêang d·ªçn d·∫πp file kh√¥ng h·ª£p l·ªá...")
    deleted_count = 0
    try:
        province_rules = load_province_rules(JSON_PATH)
        repo = Repo(REPO_PATH)
        all_files = [f for f in repo.git.ls_files().splitlines() if f.startswith(latest_folder + "/")]
        
        for file in all_files:
            commits = list(repo.iter_commits(paths=file, max_count=1))
            if not commits: continue
            is_valid, _, _ = validate_file(REPO_PATH, file, commits[0].message.strip().lower(), province_rules)
            if not is_valid:
                file_to_delete = os.path.join(cleaned_path, os.path.relpath(file, latest_folder))
                if os.path.exists(file_to_delete):
                    os.remove(file_to_delete)
                    deleted_count += 1
        
        for root, _, files in os.walk(cleaned_path):
            for file_name in files:
                if file_name.lower().endswith(".jrxml"):
                    jrxml_file_path = os.path.join(root, file_name)
                    if os.path.exists(jrxml_file_path):
                        os.remove(jrxml_file_path)
                        deleted_count += 1
        await context.bot.send_message(chat_id=chat_id, text=f"‚úÖ ƒê√£ x√≥a {deleted_count} file kh√¥ng h·ª£p l·ªá.")
    except Exception as e:
        await context.bot.send_message(chat_id=chat_id, text=f"‚ùå L·ªói khi x√≥a file: {e}")
        return

    # 4. Pull repo deploy
    await context.bot.send_message(chat_id=chat_id, text="[4/6] ‚è≥ ƒêang c·∫≠p nh·∫≠t repo deploy...")
    if not prepare_repo(DEPLOY_REPO, DEPLOY_REPO_URL, DEPLOY_REPO_BRANCH):
        await context.bot.send_message(chat_id=chat_id, text="‚ùå L·ªói khi c·∫≠p nh·∫≠t repo deploy.")
        return
    await context.bot.send_message(chat_id=chat_id, text="‚úÖ Repo deploy ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")

    # 5. Copy v√†o c√°c th∆∞ m·ª•c deploy
    await context.bot.send_message(chat_id=chat_id, text="[5/6] üöÄ ƒêang copy code s·∫°ch v√†o th∆∞ m·ª•c deploy...")
    deploy_folders = [f"BVDAKHOA_{time_str}", f"BVLONGAN_{time_str}"]
    target_latest_path = os.path.join(DEPLOY_REPO, latest_folder)
    for folder in deploy_folders:
        try:
            target_deploy_path = os.path.join(target_latest_path, folder)
            copy_folder(cleaned_path, target_deploy_path)
            await context.bot.send_message(chat_id=chat_id, text=f"‚úÖ ƒê√£ copy v√†o `{os.path.relpath(target_deploy_path, WORKSPACE)}`")
        except Exception as e:
            await context.bot.send_message(chat_id=chat_id, text=f"‚ùå L·ªói khi copy sang {folder}: {e}")
            return
            
    # 6. Commit & Push
    await context.bot.send_message(chat_id=chat_id, text="[6/6] ‚¨ÜÔ∏è ƒêang commit v√† push l√™n Git...")
    try:
        repo = Repo(DEPLOY_REPO)
        repo.git.add(A=True)
        repo.index.commit(commit_msg_today)
        repo.git.push("origin", DEPLOY_REPO_BRANCH)
        await context.bot.send_message(chat_id=chat_id, text=f"üéâ **DEPLOY TH√ÄNH C√îNG!**\nƒê√£ push l√™n git v·ªõi message:\n`{commit_msg_today}`")
    except Exception as e:
        await context.bot.send_message(chat_id=chat_id, text=f"‚ùå L·ªói khi commit/push code:\n{e}")

# ===================================
# === MAIN EXECUTION ================
# ===================================

if __name__ == "__main__":
    print("=============================================")
    print("=== KH·ªûI ƒê·ªòNG BOT DEPLOY T·ª∞ ƒê·ªòNG ===")
    print("=============================================")
    
    # B∆∞·ªõc 1: Chu·∫©n b·ªã repo ngu·ªìn
    if not prepare_repo(REPO_PATH, SOURCE_REPO_URL, SOURCE_REPO_BRANCH):
        print(" >> D·ª´ng ch∆∞∆°ng tr√¨nh do kh√¥ng th·ªÉ chu·∫©n b·ªã repo ngu·ªìn.")
        exit(1)

    # B∆∞·ªõc 2: Chu·∫©n b·ªã repo deploy
    if not prepare_repo(DEPLOY_REPO, DEPLOY_REPO_URL, DEPLOY_REPO_BRANCH):
        print(" >> D·ª´ng ch∆∞∆°ng tr√¨nh do kh√¥ng th·ªÉ chu·∫©n b·ªã repo deploy.")
        exit(1)
        
    # B∆∞·ªõc 3: Kh·ªüi ƒë·ªông bot
    print("\n--- T·∫•t c·∫£ kho git ƒë√£ s·∫µn s√†ng. Kh·ªüi ƒë·ªông bot... ---")
    if not BOT_TOKEN or BOT_TOKEN == "YOUR_TELEGRAM_BOT_TOKEN":
        print("‚ùå L·ªói: BOT_TOKEN ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng s·ª≠a l·∫°i trong script.")
        exit(1)

    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("checkinvalidfile", checkinvalidfile_command))
    app.add_handler(CommandHandler("upcode", upcode_command))
    
    print("ü§ñ Bot ƒëang ch·∫°y... Nh·∫•n CTRL+C ƒë·ªÉ d·ª´ng.")
    app.run_polling()